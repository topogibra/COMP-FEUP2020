options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(jmm)

import java.io.*;
public class jmm {
    public static void main(String args[]) throws ParseException {

        if (args.length != 1) {
            System.err.println("Usage: java jmm <file_name>");
            return;
        }

        //Reading file with InputStream
        //The file is passed as argument (1st argument)
        File file = new File(args[0]);
        InputStream input;

        try {
            input = new FileInputStream(file);
        } catch (FileNotFoundException e) {
            System.out.println("File not Found.");
            return;
        }

        jmm parser = new jmm(input);
        parser.Program();
    }
}

PARSER_END(jmm)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
	" " | "\r" | "\t" | "\n"
}

// token definition (terminal symbols)

//Types
TOKEN :
{
    <INT : "int">
    | <INT_ARR : "int[]">
    | <BOOL : "boolean">
    | <STRING : "String">
}

//
TOKEN :
{
    <CLASS : "class">
    | <EXTENDS : "extends">
    | <IMPORT : "import">
    | <PUBLIC : "public">
    | <RETURN : "return">
    | <STATIC : "static">
    | <VOID : "void">
    | <MAIN : "main">
    | <IF : "if">
    | <ELSE : "else">
    | <WHILE : "while">
    | <NEW : "new">
    | <THIS : "this">
    | <LENGTH : "length">
}

TOKEN :
{
    < PV : ";" >
    | <OPEN_BRACE: "{">
    | <CLOSE_BRACE: "}">
    | <OPEN_PARENTHESIS : "(">
    | <CLOSE_PARENTHESIS : ")">
    | <COMMA : ",">
	| <DOT : ".">
    | <OPEN_BRACKET : "[">
    | <CLOSE_BRACKET : "]">
}

TOKEN :
{
    <NOT : "!">
    | <EQUALS : "=">
    | <LESS : "<">
    | <GREATER : ">">
    | <AND : "&&">
    | <MINUS : "-">
    | <PLUS : "+">
    | <MULT : "*">
    | <DIV : "/">
}

TOKEN:
{
    <IDENTIFIER : <LETTER>(<LETTER>|<DIGIT>)* >  //Identifier is one or more letters, digits, and underscores, starting with a letter
    | <DIGIT : (["0"-"9"])+ >
    | <LETTER : ["a"-"z", "A"-"Z", "_"]>
    | <TRUE : "true">
    | <FALSE : "false">
}

void Program(): {}
{
   (ClassDeclaration())+
}

Token Type(): {Token t1;}
{
    //<TYPE : ("int" | "boolean" | "int[]" | <IDENTIFIER> )>
    (t1=<INT> | t1=<INT_ARR> | t1=<BOOL> | t1=<IDENTIFIER> )

    {return t1;}
}

void ImportDeclaration(): {}
{
    "import"
    | ""
}


void VarDeclaration(): {Token t1, t2;}
{
    //var = TYPE , IDENTIFIER, ';'
    t1=Type()
    t2=<IDENTIFIER> {
        System.out.println("[New Var] Type: " + t1.image + " Identifier: " + t2.image);
    }
    <PV>
}

void Statement(): {Token t1;}
{
    <OPEN_BRACE> Statement() <CLOSE_BRACE>
    | <IF> <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS> Statement() <ELSE> Statement()
    | <WHILE> <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS> Statement()
    | Expression() <PV>
    | t1=<IDENTIFIER>[<OPEN_BRACKET> Expression() <CLOSE_BRACKET>] <EQUALS> {System.out.println("Assignment: " + t1.image);} Expression() <PV>
}

void Expression(): {} // generic expression
{
   Expr1()
}

void ReturnExpression(): {}
{
    <RETURN> Expression()<PV>
}

void Method_Body():{}
{
    <OPEN_BRACE>
        (VarDeclaration())* (Statement())* ReturnExpression()
    <CLOSE_BRACE>
}

void Method_Arguments():{}
{
    <OPEN_PARENTHESIS>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <CLOSE_PARENTHESIS>
}

void MainMethodBody():{}
{
    <OPEN_BRACE>
        (VarDeclaration())* (Statement())*
    <CLOSE_BRACE>
}

void MainMethodArguments():{Token t1;}
{
    <OPEN_PARENTHESIS>
        <STRING>
        <OPEN_BRACKET> <CLOSE_BRACKET>
        t1=<IDENTIFIER> {System.out.println("Main argument: " + t1.image);}
    <CLOSE_PARENTHESIS>
}

void MainMethod() : {}
{
    <STATIC> <VOID> <MAIN> MainMethodArguments() MainMethodBody()
}

void MethodDeclaration(): {}
{
   Type() <IDENTIFIER>
   Method_Arguments()
   Method_Body()
}

void Class_Body(): {}
{
    <OPEN_BRACE>
        (VarDeclaration())*
        (<PUBLIC> (MainMethod() | MethodDeclaration()) )*
    <CLOSE_BRACE>
}

void Extends(): {Token ident;}
{
    <EXTENDS> ident=<IDENTIFIER> {
    System.out.println("\t[Previous Class] Extends: " + ident.image);
    }
}

void ClassDeclaration(): {Token t1;}
{
    //"class", Identifier, ["extends", Identifier], "{", Var-Declaration, MethodDeclaration  "}"
    <CLASS> t1=<IDENTIFIER> {System.out.println("[New Class] Class name: " + t1.image);}
    [Extends()]
    Class_Body()
}


void Expr1() #void: {} //add|subtract
{
   Expr2() 
   	(
	<PLUS> Expr2() #Add(2)
   	|
	<MINUS> Expr2() #Sub(2)
   	)*
}

void Expr2() #void: {} //multiply|divide
{
   Expr3()
   (
	<MULT> Expr3() #Mul(2) 
   |
	<DIV> Expr3() #Div(2)
   )*
   
}

void Expr3() #void: {} //&& | < | >
{
    Expr4()
	(
	<AND> Expr4()
	|
	<LESS> Expr4()
	|
	<GREATER> Expr4()
	)*
}

void Expr4() #void: {}  // incomplete, not sure how or what to work in it. LOOKAHEAD?
{
	Expr0()
	(
	<OPEN_BRACKET> Expr0() <CLOSE_BRACKET>
	|
	LengthFunc() 
	|
	ExprIDArgs()
	)*
}

void ExprIDArgs() #void: {} // when identifier may require arguments
{
	<DOT> Identifier() <OPEN_PARENTHESIS> <CLOSE_PARENTHESIS>
	|
	<DOT> Identifier() <OPEN_PARENTHESIS> Expr0() (<COMMA> Expr0())* <CLOSE_PARENTHESIS>
}

void Expr0() #void: {} // simpler expressions
{
	Integer()
	|
	Bool()
	|
	Identifier()
	|
	<THIS>
	|
	NewFunc()
	|
	<NOT> Expression()
	|
	<OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS>
}

void LengthFunc() #void: {} //right now only exists because i assume down the road it will need more in it
{
	<DOT><LENGTH>
}

void Bool() : {Token token} //boolean
{
	token = <TRUE>{jjtThis.jjtsetValue(token.image);}
	|
	token = <FALSE>{jjtThis.jjtsetValue(token.image);}
}

void Integer() : {Token token} //integer literal
{
	token = <DIGIT>{jjtThis.jjtsetValue(token.image);}
}

void Identifier() : {Token token} //identifier // don't know which set function 
{
//	token = <IDENTIFIER>{jjtThis._____(token.image);} //which function here?
}

void NewFunc() #void: {} //new within expression
{
	<NEW> <INT> <OPEN_BRACKET> Expression() <CLOSE_BRACKET>
	|
	<NEW> Identifier() <OPEN_PARENTHESIS><CLOSE_PARENTHESIS>
} 