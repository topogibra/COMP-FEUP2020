options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(jmm)

   import java.io.*;
   public class jmm {

       public static int MAX_ERRORS = 100;
       public static int NUM_ERRORS = 0;

       public void parseProgram() throws ParseException {
           jmm.NUM_ERRORS = 0;
           this.Program();
       }

       public static boolean isStatementStart(Token t) {
           switch (t.kind) {
               case OPEN_BRACE:
               case IF:
               case WHILE:
               case IDENTIFIER:
               case DIGIT:
               case TRUE:
               case FALSE:
               case THIS:
               case NEW:
               case NOT:
               case OPEN_PARENTHESIS:
                   return true;
               default:
                   return false;
           }
       }

       public static void main(String args[]) throws ParseException {

           if (args.length != 1) {
               System.err.println("Usage: java jmm <file_name>");
               return;
           }

           //Reading file with InputStream
           //The file is passed as argument (1st argument)
           File file = new File(args[0]);
           InputStream input;

           try {
               input = new FileInputStream(file);
           } catch (FileNotFoundException e) {
               System.out.println("File not Found.");
               return;
           }

           jmm parser = new jmm(input);
           parser.parseProgram();
       }
   }


PARSER_END(jmm)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
	" " | "\r" | "\t" | "\n" | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> |  <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

// token definition (terminal symbols)

//Types
TOKEN :
{
    <INT : "int">
    | <INT_ARR : "int[]">
    | <BOOL : "boolean">
    | <STRING : "String">
}

//Dedicated words
TOKEN :
{
    <CLASS : "class">
    | <EXTENDS : "extends">
    | <IMPORT : "import">
    | <PUBLIC : "public">
    | <RETURN : "return">
    | <STATIC : "static">
    | <VOID : "void">
    | <MAIN : "main">
    | <IF : "if">
    | <ELSE : "else">
    | <WHILE : "while">
    | <NEW : "new">
    | <THIS : "this">
    | <LENGTH : "length">
}

//Seperators
TOKEN :
{
    < PV : ";" >
    | <OPEN_BRACE: "{">
    | <CLOSE_BRACE: "}">
    | <OPEN_PARENTHESIS : "(">
    | <CLOSE_PARENTHESIS : ")">
    | <COMMA : ",">
	| <DOT : ".">
    | <OPEN_BRACKET : "[">
    | <CLOSE_BRACKET : "]">
}

//Operators
TOKEN :
{
    <NOT : "!">
    | <EQUALS : "=">
    | <LESS : "<">
    | <GREATER : ">">
    | <AND : "&&">
    | <MINUS : "-">
    | <PLUS : "+">
    | <MULT : "*">
    | <DIV : "/">
}

//Variables Values
TOKEN:
{
    <TRUE : "true">
    | <FALSE : "false">
    | <DIGIT : (["0"-"9"])+ >
    | <IDENTIFIER : (<LETTER>|<DOLLAR_SIGN>)(<LETTER>|<DOLLAR_SIGN>|<DIGIT>)* >  //Identifier is one or more letters, digits, and underscores, starting with a letter
    | <#DOLLAR_SIGN : "$">
    | <#LETTER : ["a"-"z", "A"-"Z", "_"]>
}

void Program() #void: {}
{
    ImportDeclaration()
    ClassDeclaration()
    {
        System.out.println(jmm.NUM_ERRORS + " errors encountered");
        if(jmm.NUM_ERRORS > 0){
            throw new ParseException();
        }
    }
}

void ImportDeclaration() #void: {}
{
    (
        <IMPORT>
        ImpClass()
        <PV>
    )*
}

void ImpClass() #void: {}
{
    (<STATIC>)?
    <IDENTIFIER>
    (
        <DOT> ImpFunc()
        (Type() | <VOID> )?
    )?
}

void ImpFunc() #void: {}
{
    <IDENTIFIER>
    <OPEN_PARENTHESIS>
    (
        ImportType()
        (
        <COMMA>
        ImportType()
        )*
    )?
    <CLOSE_PARENTHESIS>
}

void ImportType() #void: {}
{
    <VOID> | Type()
}

// ############### CLASS DECLARATION #################
void ClassDeclaration() #void: {Token t1;}
{
    <CLASS> t1=<IDENTIFIER> {System.out.println("[New Class] Class name: " + t1.image);}
    [Extends()]
    ClassBody()
}

void Extends() #void: {Token ident;}
{
    <EXTENDS> ident=<IDENTIFIER> {
    System.out.println("\t[Previous Class] Extends: " + ident.image);
    }
}

void ClassBody() #void: {}
{
    <OPEN_BRACE>
        (VarDeclaration())*
        (<PUBLIC> (MainMethod() | MethodDeclaration()) )*
    <CLOSE_BRACE>
}

// ############### VAR DECLARATION #################
void VarDeclaration() #void: {Token t1;}
{
    ( t1=Type() | t1=<IDENTIFIER> )
    VarDeclaration1(t1)
}

void VarDeclaration1(Token t1) #void: {Token t2;}
{
    t2=<IDENTIFIER> {
        System.out.println("[New Var] Type: " + t1.image + " Identifier: " + t2.image);
    }
    <PV>
}

Token Type() #void: {Token t1;}
{
    (t1=<INT> | t1=<INT_ARR> | t1=<BOOL>)
    {return t1;}
}

// ############### MAIN METHOD #################
void MainMethod() #void: {}
{
    <STATIC> <VOID> <MAIN> MainMethodArguments() MainMethodBody()
}

void MainMethodArguments() #void: {Token t1;}
{
    <OPEN_PARENTHESIS>
        <STRING>
        <OPEN_BRACKET> <CLOSE_BRACKET>
        t1=<IDENTIFIER> {System.out.println("[Main Method] Argument name: " + t1.image);}
    <CLOSE_PARENTHESIS>
}

void MainMethodBody() #void: {}
{
    <OPEN_BRACE>
        MethodCode()
    <CLOSE_BRACE>
}

// ############### METHOD DECLARATION #################
void MethodDeclaration() #void: {Token t1, t2;}
{
   t1=Type() t2=<IDENTIFIER> { System.out.println("[New Method] Return Type: " + t1.image + " Identifier: " + t2.image); }
   MethodArguments()
   MethodBody()
}

void MethodArguments() #void: {}
{
    <OPEN_PARENTHESIS>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <CLOSE_PARENTHESIS>
}

void MethodBody() #void: {}
{
    <OPEN_BRACE>
        (MethodCode())?
        ReturnExpression()
    <CLOSE_BRACE>
}

void MethodCode() #void: {Token t1;}
{
    {System.out.println("In Method Code");}
    t1=Type() VarDeclaration1(t1) MethodCode()
    | ( t1=<IDENTIFIER> (
        MethodCode2(t1)
        | ( VarDeclaration1(t1) MethodCode() )
       )
    )
    | ( Statement1() (Statement())*)
}

void MethodCode2(Token t1) #void: {}
{
    IdentifierOptions(t1)
    (Statement())*
}

void IdentifierOptions(Token t1) #void: {}
{
    ( Array() [Assignment1(t1)] ) //Last option of Statement and 2nd option of expression
    | Assignment1(t1)
    | ( <DOT> DotFunc() (<PV>)?)
    | <PV>
}

void ReturnExpression() #void: {}
{
    <RETURN> ExpressionIdentifier() <PV> {System.out.println("[Return Expression]");}
}

// ############### STATEMENT #################
void Statement() #void: {Token t1;}
{
    Statement1()
    | ( t1=<IDENTIFIER> IdentifierOptions(t1) )
}

void Statement1() #void: {}
{
    ( <OPEN_BRACE> (Statement())* <CLOSE_BRACE> )
    | <IF> IfStatement()
        | <WHILE> WhileStatement()
    | ( Expression() <PV> )
}

void IfStatement() #void: {}
{
    {System.out.println("[If]");}
    <OPEN_PARENTHESIS>
        ExpressionIdentifier()
    <CLOSE_PARENTHESIS>
        Statement()
    <ELSE> {System.out.println("[Else]");}
        Statement()
}

void WhileStatement() #void: {}
{
     {System.out.println("[While]");}
     <OPEN_PARENTHESIS>
     try {
            ExpressionIdentifier()
            <CLOSE_PARENTHESIS>
     } catch(ParseException e) {
           System.out.println(e.toString());

           Token t;
           jmm.NUM_ERRORS++;

           if(jmm.NUM_ERRORS == jmm.MAX_ERRORS){
               System.out.println("Reached max number of errors, aborting");
               throw new ParseException();
           }

           do {
             t = getNextToken();

             if (t.kind == CLOSE_PARENTHESIS) {
                Token t1 = getToken(1);

                if (jmm.isStatementStart(t1))
                    break;
             }

             //System.out.println("Token image: " + t.image);
           }
           while (t.kind != OPEN_BRACE && t.kind != 0);
     }
     Statement()
}

void Assignment(Token t1) #void: {}
{
    (Array())?
    Assignment1(t1)
}

void Array() #void: {}
{
    <OPEN_BRACKET> ExpressionIdentifier() <CLOSE_BRACKET>
}

void Assignment1(Token t1) #void: {}
{
    <EQUALS> {System.out.println("[New Assignment] Identifier: " + t1.image);} ExpressionIdentifier() <PV>
}

// ############### EXPRESSION #################
void Expression() #void: {}
{
    <NOT> ExpressionIdentifier() |
    AndExpression()
}

void AndExpression() #void: {}
{
    LessExpression()
    ( <AND> ExpressionIdentifier() )?
}

void LessExpression() #void: {}
{
    AddSubExpression()
    ( <LESS> AddSubExpressionIdentifier() )?
}

void AddSubExpression() #void: {}
{
    MultDivExpression()
    (
        <PLUS> MultDivExpressionIdentifier()
        | <MINUS> MultDivExpressionIdentifier()
    )*
}

void MultDivExpression() #void: {}
{
    BracketExpression()
    (
        <MULT> BracketExpressionIdentifier()
        | <DIV> BracketExpressionIdentifier()
    )*
}

void BracketExpression() #void: {}
{
    DotExpression()
    (
        <OPEN_BRACKET>
            BracketExpressionIdentifier()
        <CLOSE_BRACKET>
    )?
}

void DotExpression() #void: {}
{
    Values()
    (<DOT> DotFunc())?
}

void ExpressionIdentifier() #void: {}
{
     <NOT> ExpressionIdentifier()
     | AndExpressionIdentifier()
}

void AndExpressionIdentifier() #void: {}
{
     LessExpressionIdentifier()
    ( <AND> ExpressionIdentifier())?
}

void LessExpressionIdentifier() #void: {}
{
    AddSubExpressionIdentifier()
    ( <LESS> AddSubExpressionIdentifier())?
}

void AddSubExpressionIdentifier() #void: {}
{
    MultDivExpressionIdentifier()
    (
        <PLUS> MultDivExpressionIdentifier()
        | <MINUS> MultDivExpressionIdentifier()
    )*
}

void MultDivExpressionIdentifier() #void: {}
{
    BracketExpressionIdentifier()
    (
        <MULT> BracketExpressionIdentifier()
        | <DIV> BracketExpressionIdentifier()
    )*
}

void BracketExpressionIdentifier() #void: {}
{
    DotExpressionIdentifier()
    (
        <OPEN_BRACKET>
        BracketExpressionIdentifier()
        <CLOSE_BRACKET>
    )?
}

void DotExpressionIdentifier() #void: {}
{
    ValuesIdentifier()
    (<DOT> DotFunc())?
}

void Values() #void: {} // simpler expressions
{
	<DIGIT>
	| <TRUE>
	| <FALSE>
	| <THIS>
	| <NEW> NewFunc()
	| <OPEN_PARENTHESIS> ExpressionIdentifier() <CLOSE_PARENTHESIS>
}

void ValuesIdentifier() #void: {}
{
    <IDENTIFIER>
    | Values()
}

void NewFunc() #void: {} //new within expression
{
	{System.out.println("[New]");}
	(
	    ( <INT> <OPEN_BRACKET> ExpressionIdentifier() <CLOSE_BRACKET> )
	    | ( <IDENTIFIER> <OPEN_PARENTHESIS> <CLOSE_PARENTHESIS> {System.out.println("[Function call]");} )
	)
}

void DotFunc() #void: {}
{
    <LENGTH>
    | <IDENTIFIER> FuncArguments()
}

void FuncArguments() #void: {}
{
    <OPEN_PARENTHESIS> {System.out.println("[Function call]");}
        [ ExpressionIdentifier() (<COMMA> ExpressionIdentifier() )* ]
    <CLOSE_PARENTHESIS>
}
