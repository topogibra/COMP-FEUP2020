** PROJECT TITLE: Compiler of the Java-- language to Java Bytecodes

** GROUP: COMP2020-1C

NAME1: Gaspar Santos Pinheiro, NR1: 201704700, GRADE1: 18.5, CONTRIBUTION1: 25%

NAME2: Filipe Ferreira, NR2: 201706086, GRADE2: 18.5, CONTRIBUTION2: 25%

NAME3: João Miguel Matos Monteiro, NR3: 201506130, GRADE3: 18.5, CONTRIBUTION3: 25%

NAME4: José Pedro Baptista, NR4: 201705255, GRADE4: 18.5, CONTRIBUTION4: 25%

GLOBAL Grade of the project: 18.5

** SUMMARY:

    The compiler, named jmm, translates programs in Java-- into java bytecodes. The compiler generates .j files of the classes with JVM instructions accepted by jasmin, a tool that translates those classes in Java bytecodes (classfiles).
    The generated classes given Java-- code can be integrated in a Java application. Those classes can invoke Java methods previously compiled to bytecodes.

** EXECUTE:

    The generated classes given Java--code can be integrated in a Java application. Those classes can invoke Java methods previously compiled to bytecodes(the utility of this concept will be detailed later in this document).The jmmcompiler is executed using the following notation:

    java main.jmm [-d] [-r=<num>] [-o] <input_file.jmm>

    or

    java –jar jmm.jar [-d] [-r=<num>] [-o] <input_file.jmm>

    Where <input_file.jmm> is the Java-- class we would like to compile.
    The -d option tells the compiler to not print the AST generated by the parser and to not throw the exceptions created during the semantic analysis and the syntatic analysis.
    The "–r" option tells the compiler to use only the first <num> registers of the JVM when assigning the local variables used in each Java-- function to the local JVM variables.
    Without the "–r" option (similar to –r=0), the compiler will use the available JVM local variables to store the local variables used in each Java-- function.
    With the "–o" option, the compiler would perform a set of code optimizations, except we didn't implement it.


** DEALING WITH SYNTACTIC ERRORS:

    The parsers deals with syntatic errors only in the while expression and at most reports a max number of syntatic erros of 10. With the error report we include the line and column of the error and the type of error it is, informing the expected token. It also deals with the expression not being closed with a parenthesis.

** SEMANTIC ANALYSIS:

    Our semantic analyser accepts a maximum number of 10 errors, if it finds an error it skips the ast node where it found the error and prints the line, column and points at the token that is wrong. The error message is in the same format as a java error message. These are some of the errors that the semantic analysis can find:

    - MethodNotFound - the method was not found.
    - AttributeDoesNotExist - used when the length attribute is not called on an array.
    - ClassNotImported - the class wasn't imported.
    - ConditionNotBoolean - used when a condition expression doesn't return a boolean.
    - ExpectedArray - used when a method expects an array to be passed, but receives other type.
    - ExtendedClassEqualsClass - used when a class extends itself.
    - ImportClassEqualsClass - used when a class that is defined in the file is also imported.
    - IndexNotInt - used when there is an array access, and the given index isn't an integer.
    - MethodCallOnPrimitive - trying to call a method on a primitive type. (e.g. 1.callMethod())
    - MethodNotFound - Trying to call a method that is not imported/defined
    - MissingReturnStatement - Missing a return statement on a method that is declared to return a non-void.
    - NotDeclared -  trying to use a variable that was not declared.
    - NotSameType - trying to assign a type to a variable that was not declared as such.
    - NotStatement - Invalid statements. ( e.g. 2+2; or true && false;)
    - NotStaticMethod - Trying to call a non-static method from a non instatiated object.
    - ReturnNotSameType - The type used int he return statement is not the same as the one that is defined.
    - StaticClassImport - used keyword static when importing a class constructor.
    - ThisFromStaticContext - tried to use this in a static context, probably in the main method.
    - UnexpectedType - the type expected is not the actual one. (e.g. in the case of a method wanting an int argument and giving it an int array, or adding two booleans, or using '<' with one boolean and an int)
    - VarNotInitialized - the variable used is not initialized

** INTERMEDIATE REPRESENTATIONS (IRs):

    For the intermediate representation we used the AST obtained by the javacc parser. Code generation takes as input the AST and the symbols table of the compiled Java-- class.

** CODE GENERATION:

    The class CodeGenerator is responsible for the generation of the .j file based on the AST generated by the parsed and the SymbolsTable created by the SymbolsTableGenerator class that it received as parameters.
    We start by generating the definition of the class and defining its parent class with 'super'. Then the fields are generated, following the constructor of the class.
    We use a string builder to generate the string that corresponds to code of each method of the class and at the end of the processing each method the string of the string builder is appended to the .j file of the compiled java-- class.


** OVERVIEW:

    As it can bee seen in the method compileFile of the jmm class, our compiler follows diferent stages:
    1 - Uses the JJTree parser to parse the file for syntatic errors and to create an AST. (Stops if it reaches the maximum number of errors)
    2 - Then we generate the symbols table based on that AST, SymbolsTableGenerator, registering the imports and declared variables for each method.
    3 - We run again with the SemanticAnalyser class, to analyze the semantics of the program. (if it reaches the maximum number of errors it stops here)
    4 - For each of the methods of the class we execute a dataflow analysis, DataFolowAnalyser, and generate the CFG to calculate the liveness of each local variable. With this information we create a Register-Interference Graph and apply the Graph Coloring Algorithm to check the minimum number of registers that can be used for the given method. (This step is only run with the -r flag)
    5 - We generate the JVM instructions running through the AST again but with the symbols table as well. At this point we assume that everything is fine and all errors should've been detected in the syntatic and semantic phases.

**TASK DISTRIBUTION:

    Most of the code was made in peer programing and with each member contributing equally.

**PROS:

    - Functional, it works™.
    - Human friendly error messages.
    - We accept contructors from imported classes with variable number of arguments.
    - We allow assignments where the left side is an array access from a returned array reference. (e.g.: this.getArray()[0] = 1)
    - Void functions don't need to have a return at the end of the method.
    - The -r option is partially implemented, allowing for the optimization of the number of registers allocated.

**CONS:

    - The -o option is not implemented.
    - The Graph Coloring Algorithm is not fully implemented: the spilling step was not completed.
    - Our code is a bit recursive which can lead to some performance issues in extremely large statements or expressions.